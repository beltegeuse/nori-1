<div style="margin-top:-20px; text-align:justify">
	<h3>Preliminaries</h3>
	<p>
		In this exercise you will generate sample points on various domains:
		disks, spheres, hemispheres, and a few more. The base code has been
		extended with an interactive visualization and testing tool to make
		working with point sets as intuitive as possible. Note that all work
		you do in this assignment will serve as building blocks in later
		assignments when we apply Monte Carlo integration to render images.
	</p>

	<p>
		Begin by importing the base code updates into your repository by
		running <tt>git pull</tt> and recompiling. If there were any concurrent
		changes to the same file, you may have to perform a <em>merge</em> (see
		the git tutorials under "Preliminaries" for more information). Once the
		compilation finishes, you should see another executable named
		<tt>warptest</tt>. Run this executable to launch the interactive
		warping tool, which allows you to visualize the behavior of different
		warping functions given a range of input point sets (independent, grid
		and stratified).
	</p>
	<p>
		This exercise is split into several parts; in each case, you will be
		asked to implement a sample warping scheme and an associated
		probability distribution function. It is crucial that both are
		<em>consistent</em> with respect to each other (i.e. that warped
		samples have exactly the distribution described by the density function
		you implemented). Otherwise, errors would arise if we used inconsistent
		warpings for Monte Carlo integration. The warping test tool comes with
		a \(\chi^2\) test to check this consistency condition. 
	</p>

	<div class="alert alert-danger" role="alert">
		Note that passing the test
		does not generally imply that your implementation is correct—for
		instance, the test may not have enough "evidence" to generate a
		failure, or potentially the warping function and the density function
		are both incorrect in the same manner. Use your judgment and don't
		rely on this test alone.
	</div>

	<div class="row" style="margin: 30px">
		<div class="col-md-3">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/warp-square-points.png"><img src="images/warp-square-points.png"/></a>
				<div class="caption">
					The input point set (stratified samples passed through a "no-op" warp function)
				</div>
			</div>
		</div>
		<div class="col-md-3">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/warp-square-chi2.png"><img src="images/warp-square-chi2.png"/></a>
				<div class="caption">
					This point set passed the test for uniformity.
				</div>
			</div>
		</div>
		<div class="col-md-3">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/warp-disk-points.png"><img src="images/warp-disk-points.png"/></a>
				<div class="caption">
					A more interesting case that you will implement
					(with a grid visualization of the mapping)
				</div>
			</div>
		</div>
		<div class="col-md-3">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/warp-disk-chi2.png"><img src="images/warp-disk-chi2.png"/></a>
				<div class="caption">
					This warping passed the tests as well.
				</div>
			</div>
		</div>
	</div>


	<h3>Part 1: Sample Warping <em>(70 points)</em></h3>
	<p>
		Implement the missing functions in <code>class Warp</code> found in
		<tt>src/warp.cpp</tt>. This class consists of various warp methods that
		take as input a 2D point \((s, t) \in [0, 1) \times [0, 1) \) (and
		maybe some other domain specific parameters) and return the warped 2D
		(or 3D) point in the new domain. Each method is accompanied by another
		method that returns the probability density with which a sample was
		picked. Our default implementations all throw an exception, which shows
		up as an error message in the graphical user interface. Note that the
		slides on the course website provide a useful recipe for warping the
		samples and as well as computing the densities, and the PBR textbook
		also contains considerable information on this topic.
	</p>

	<ul>
		<li>
			<h4><code>Warp::squareToUniformDisk</code> and <code>Warp::squareToUniformDiskPdf</code> <em> (10 Points)</em></h4>
			<p>
				Implement a method that transforms uniformly distributed 2D
				points on the unit square into uniformly distributed points on
				a planar <em>disk</em> with radius 1 centered at the origin. Next,
				implement a probability density function that matches your
				warping scheme.
			</p>
		</li>
		<li>
			<h4><code>Warp::squareToUniformSphere</code> and <code>Warp::squareToUniformSpherePdf</code> <em> (10 Points)</em></h4>
			<p>
				Implement a method that transforms uniformly distributed 2D
				points on the unit square into uniformly distributed points on
				the <em>unit sphere</em> centered at the origin. Implement a matching
				probability density function.
				<div class="alert alert-info" role="alert">
					<b>Hint</b>: You could save some time by implementing a new <code>Warp::squareToUniformCylinder</code>
					function and use the hat-box theorem discussed in class to solve not only this problem,
					but also the following two.
				</div>
			</p>
		</li>
		<li>
			<h4><code>Warp::squareToUniformHemisphere</code> and <code>Warp::squareToUniformHemispherePdf</code> <em> (5 Points)</em></h4>
			<p>
				Implement a method that transforms uniformly distributed 2D
				points on the unit square into uniformly distributed points on
				the <em>unit hemisphere</em> centered at the origin and oriented in
				direction \((0, 0, 1)\). Add a matching probability density
				function.
			</p>
		</li>
		<li>
			<h4><code>Warp::squareToUniformSphericalCap</code> and <code>Warp::squareToUniformSphericalCapPdf</code> <em> (5 Points)</em></h4>
			<p>
				Implement a method that transforms uniformly distributed 2D
				points on the unit square into uniformly distributed points on
				the <em>spherical cap</em> centered at the origin and oriented in
				direction \((0, 0, 1)\). Add a matching probability density
				function.
				A spherical cap is the subset of a unit sphere whose directions
				make an angle of less than \(\theta\) with the central direction. 
				Note that the above functions expects \(cos\,\theta\) as a parameter.
			</p>
		</li>
		<li>
			<h4><code>Warp::squareToCosineHemisphere</code> and <code>Warp::squareToCosineHemispherePdf</code> <em> (5 Points)</em></h4>
			<p>
				Transform your 2D point to a point distributed on the unit
				hemisphere with a cosine density function
				\[
				p(\theta)=\frac{\cos\theta}{\pi},
				\]
				where \(\theta\) is the
				angle between a point on the hemisphere and the north pole.
			</p>
		</li>

		<li>
			<h4><code>Warp::squareToBeckmann</code> and <code>Warp::squareToBeckmannPdf</code> <em> (35 Points)</em></h4>
			<p>
				Transform your 2D point to a point distributed on the unit
				hemisphere with a cosine weighted Beckmann density function (we
				will describe applications of this distribution in class soon).
				Including the cosine weighting, this distribution is given by the following expression:
				\[
					p(\theta,\phi) = D(\theta) \cos{\theta} = \frac{e^{\frac{-\tan^2{\theta}}{\alpha^2}}}{\pi\, \alpha^2 \cos^4 \theta }\cos \theta
				\]
				Where \(\alpha\) is a user specified roughness parameter and
				\(\theta\) is the angle between a direction on the hemisphere
				and the north pole.

				<ul>
					<li> 
						Begin by computing the cumulative distribution \(P(\theta,\phi)\) of \(p(\theta,\phi)\) and use that to compute the integral of \(p(\theta,\phi)\) over the entire hemisphere, i.e.:
						\[
							I = P(\pi/2,2\pi) = \int_0^{2\pi} \int_0^{\frac{\pi}{2}} p(\theta,\phi) \sin{\theta} ~ d\theta ~ d\phi
						\]
						Verify that your result integrates to 1. Show your steps in your report. You can easily add LaTeX style math in your report by adding the following line towards the end of your file
						<pre class="prettyprint lang-html">
&lt;script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;</pre>
						Usage examples can be found on the <a href="http://docs.mathjax.org/en/latest/start.html">MathJax</a> page
						and <a href="http://www.ianholden.com/how-to/how-to-use-mathjax/">here</a>.

							<div class="alert alert-info" role="alert"><b>Hint</b>: You might find integration by substitution useful,
								e.g. using the mappings \(x = \cos{\theta}\) and \(\tan^2{\theta} = \frac{1-x^2}{x^2}\).
								In addition this identity might come in handy: 
									\[
									\int f'(x) ~ e^{~f(x)} dx = e^{~f(x)} + C\text{, where } C\in\mathbb{R}
									\]
							</div>

					</li>
					<li>
						Now use the recipe discussed in class to invert the CDF and turn it into a method for sampling points
						that match the Beckmann distribution. Show your steps.
					</li>
					<li> 
						Implement <code>Warp::squareToBeckmann</code> and <code>Warp::squareToBeckmannPdf</code>
					</li>

				</ul>
			</p>
		</li>

	</ul>
	<h3>Part 2: Validation <em>(30 points)</em></h3>
	<p>
		Pass all \(\chi^2\) tests of the above warpings and include screen shots in your report.
	</p>
<h3> Hacker Points: Hierarchical Sample Warping <em>(20 points)</em></h3>

	<div class="alert alert-info" role="alert"><b>Disclaimer</b>: Hacker points are “underpriced” bonus points 
	for the daring few. Sometimes you might be required to implement something that was not taught in class and 
	you might have to do some research and creative thinking. Hacker Points are awarded only to students who 
	implemented all of the remaining assignment. In addition Hacker Points are either fully awarded or not awarded at all.
	</div>

	<div class="row" style="margin: 30px">
		<div class="row-centered">
		<div class="col-md-3 col-centered">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/envmap-1.jpg"><img src="images/envmap-1.jpg"/></a>
				<div class="caption">
					A lightprobe by <a href="http://dativ.at/lightprobes/">Bernhard Vogl</a>.
				</div>
			</div>
		</div>
		<div class="col-md-3 col-centered">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/envmap-2.jpg"><img src="images/envmap-2.jpg"/></a>
				<div class="caption">
					A simple scene rendered with this lightprobe.
				</div>
			</div>
		</div>
		</div>
	</div>

	<p> 
		The goal of this exercise is to implement hierarchical sample warping,
		which will come in very handy if you decide you'll want to later add
		<a href="http://ict.usc.edu/pubs/Image-Based%20Lighting.pdf">Image Based Lighting</a> (IBL)
		to your renderer for the final project. Lighting with captured
		real-world lighting conditions ("<em>lightprobes</em>") is a
		relatively cheap and simple way to add considerable realism to a
		rendering. Note that we don't expect you to add the rendering-related
		parts yet; this exercise is just about the warping scheme.
	</p>
	<p>
		You can assume that a non-negative grayscale image is given as an
		input (this image records the per-pixel luminance values of an IBL
		light probe). The image is interpreted as a probability density of
		samples distributed on a 2D rectangular domain, hence the goal is to
		generate samples proportionally to these luminance values.
		Strictly speaking, the image is not really a density function because
		it does not integrate to one—we simply apply a normalization factor
		to circumvent this problem.
	</p>


	<div>
		<p>
			Hierarchical Sample Warping works as follows: 
			<ul>
				<li> Input: grayscale image and \(N\) samples uniformly distributed on the unit square.</li>
				<li> Subdivide the image in two equal-sized parts along the \(x\)-axis and sum up the luminance values in each part. </li>
				<li> Warp input sample set along the \(x\) axis such that the
					number of samples allocated to each part matches ratio of
					the summed luminance computed in the last step.</li>
				<li> Repeat the steps above for the \(y\)-axis. </li>
				<li> Recursively repeat these two steps for each quadrant until the process cannot sub-divide the image anymore.</li>
			</ul>
			You will want to use a data structure such as a quad-tree to accelerate the second step.
		</p>
	</div>
	<div class="row-centered">
		<div class="thumbnail col-md-5 col-centered">
			<a class="fancybox" href="images/hsw.png"><img src="images/hsw.png"/></a>
			<div class="caption">
				Hierarchical Sample Warping example with a 2x2 pixel image.
			</div>
		</div>
	</div>
	
	<h4> What to submit </h4>
	<p>
		<ul>
			<li> A correct implementation of the hierarchical sample warping algorithm described above. </li> 
			<li> A modified version of the <tt>warptest</tt> user interface that visualizes your generated points sets.</li> 
			<li> Two screen shots of the \(\chi^2\)-test, which verifies that your warping function and density function are mutually consistent.
				The first should be with a simple
				2x2 pixel image as shown above, and for the second, you can choose any
				light probe you like (<a href="http://gl.ict.usc.edu/Data/HighResProbes/">Paul Debevec</a> and
				<a href="http://dativ.at/lightprobes/">Bernhard Vogl</a> provide many light probes free of charge).
			</li>
		</ul>
	</p>

</div>
