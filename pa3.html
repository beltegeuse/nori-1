<div style="margin-top:-20px; text-align:justify">

	\(
	   \def\bold#1{\boldsymbol{#1}}
	\)

	<h3>Preliminaries</h3>


	<p>
		Begin by importing the base code updates into your repository by
		running <tt>git pull</tt>, cmake and recompiling. If there were any concurrent
		changes to the same file, you may have to perform a <em>merge</em> (see
		the git tutorials under "Preliminaries" for more information).
	</p>

	<p>
		In this exercise you will use your point sets in the context of rendering. You will
		be implementing various flavors of direct illumination integrators with different
		sampling distributions. You will add new emitters with finite extent and a new microfacet
		BRDF. The integral you will be numerically computing with your integrators at the first camera
		intersection is:
	</p>
	\[
		L_o (p,\omega_o) = L_e(p,\omega_o) + \int_{H^2} L_r(p,\omega_o,\omega_i) ~ d \omega_i
	\]
	where
	\[
		L_r(p,\omega_o,\omega_i) = f_r (p,\omega_o,\omega_i) ~ L_d (p,\omega_i) \left| \cos{\theta_i} \right|

	\]
	<p>
		Note that this time we will be having emitters with finite extent, which can be directly visible to the camera.
		In these cases \(L_e\) should be returning emitted radiance towards \(\omega_o\) when a camera ray intersects one.
	</p>

	<h3>Part 1: Light Sampling <em>(55 points)</em></h3>
	<ul>
		<li>
		<h4>Integrator Implementation <em>(10 Points)</em></h4>

		<p>
			In this part you will implement a new direct illumination integrator (<tt>direct_ems</tt>)
			which can integrate incident radiance by performing emitter sampling. In addition to point lights this integrator will
			be able to handle two additional types of emitters: distant disk lights and mesh (area) lights. These new emitters
			can be fully, partially or not at all visible from a point in your scene, so you will perform MC integration to compute
			reflected radiance (accounting also for visibility) at your first camera intersection.
			For this part of the assignment you will distribute your samples for the new emitters according to an emitter
			specific density function \(\text{pdf}_\text{em}\):
			\[
				L_o (p,\omega_o) \approx \frac{1}{N} \sum^N \left( L_e(p,\omega_o) + \frac{L_r(p,\omega_o,\omega_{i,e})}{\text{pdf}_{\text{em}}(\omega_{i,e})} \right)\\
			\]
		</p>
		</li>

		<li>
			<h4>Distant Disk Light <em> (10 Points)</em></h4>
			<p>
				There can be at most one distant disk emitter per scene and is defined
				by its radiance, a <tt>toWorld</tt> transformation and the angle subtended
				by the light source as seen by object in the scene when there is no occlusion
				\(\theta_a \in [0^o,180^o]\). For a value of \(\theta_a = 0\) the emitter is
				basically non existent and for a value of \(\theta_a = 180\) the emitter is a constant
				spherical environment map. In addition the emitter can be rotated using a
				<tt>toWorld</tt> transformation. You can safely assume that for this
				emitter, only rotations are allowed as transformations. When no transformation
				is given (i.e \(\text{toWorld} = \bold{I} \)) then the subtended angle
				is measured (in degrees) from the Z-axis \([0,0,1]\). Here is how instances
				of <tt>distantdisk</tt> will be specified in Nori's scene description language:
			</p>
			<pre class="prettyprint linenums lang-xml">
&lt;scene&gt;
    &lt;!-- Define a distant disk emitter --&gt;
    &lt;emitter type="distantdisk"&gt;
        &lt;!-- Set the radiance to a 60 W/m<sup>2</sup>sr  for all channels --&gt;
        &lt;color name="radiance" value="60"/&gt;

        &lt;!-- Set the subtended angle to 5 degrees --&gt;
        &lt;float name="thetaA" value="5"/&gt;

        &lt;!-- Rotate the disk 30 degrees counter-clockwise around the Y-axis --&gt;
        &lt;transform name=<tt>toWorld</tt>&gt;
            &lt;rotate axis="0,1,0" value="30"/&gt;
        &lt;/transform&gt;

    &lt;/emitter&gt;

    &lt;!-- ..... --&gt;
&lt;/scene&gt;
			</pre>

				<ul>
					<li>
					<h4> Radiance Evaluation Method <em>(5 points)</em> </h4>
					In your <tt>DistantDisk</tt> class implement a method which will be called whenever a ray escapes your scene or when doing shadow connections. After transforming \(\bold{\omega_e}\) in the emitters local coordinate system, this method will return the constant radiance value when the angle from Z-axis is less or equal than \(\theta_a\) and zero otherwise. Remember to convert your angles to radians before
					using the standard trigonometric functions. Here is a usage example for the world-to-local and local-to-world transformations:

					<div class="row">
						<div class="col-md-6">
							<pre class="prettyprint linenums " >
//Constructor example

/* Read a toWorld transform from the xml.
 * If not use the identity matrix */
m_emitterToWorld = propList.getTransform(
		<tt>toWorld</tt>, Transform());

/* Invert the toWorld transformation */
m_worldToEmitter = m_emitterToWorld.inverse();

//...
							</pre>
						</div>

						<div class="col-md-6">
							<pre class="prettyprint linenums ">
//Usage Example

/* Convert a world space direction to
 * a local direction and vice versa */

Vector3f d1_local = m_worldToEmitter * d1_world;
Vector3f d2_world = m_emitterToWorld * d2_local;

//...


							</pre>
						</div>
					</div>
					</li>

					<li>
						<h4> Sampling and Density Methods <em>(5 points)</em> </h4>
						Implement a method for generating a world space direction uniformly over the subtended solid angle of the distant disk light. You might find <code>Warp::squareToUniformSphericalCap</code> and your <tt>toWorld</tt> transformations useful. Implement another method which given a world space direction generated
						using your sampling method returns the probability density used.
					</li>
				</ul>
		</li>

		<li>
			<h4>Mesh Area Light<em> (25 Points)</em></h4>
			<p>
				The mesh area light source is an area light source that can be attached to meshes. It emits radiance uniformly in all directions from each triangle of the mesh.
				It is parametrized by radiance. Here is how instances of <tt>area</tt> emitters will be specified in Nori's scene description language:
			</p>
			<pre class="prettyprint linenums lang-xml">
&lt;scene&gt;
    &lt;!-- Load a Wavefront OBJ file named "mesh.obj" --&gt;
    &lt;mesh type="obj"&gt;
        &lt;string name="filename" value="mesh.obj"/&gt;

        &lt;!-- Turn the mesh into an area light source --&gt;
        &lt;emitter type="area"&gt;
            &lt;!-- Assign a uniform radiance of 1 W/m<sup>2</sup>sr --&gt;
            &lt;color name="radiance" value="1,1,1"/&gt;
        &lt;/emitter&gt;
    &lt;/mesh&gt;

    &lt;!-- ..... --&gt;
&lt;/scene&gt;
			</pre>

				<ul>
					<li>
					<h4> Radiance Evaluation Method <em>(5 points)</em> </h4>
						In your <tt>AreaEmitter</tt> class implement a method which can be called by the integrators whenever a ray intersects your mesh emitter.
						Given a camera intersection point \(p_c\) with an emitter you should return the associated radiance value when the point lies on the front side of an emissive
						triangle. In addition this method should return the radiance (ignoring occlusion for now) when a direction towards a sampled point on the emitter mesh is hitting from the front side.
					</li>

					<li>
						<h4> <tt>Mesh</tt> Sampling and Density Methods <em>(15 points)</em> </h4>
						Get familiar with the <tt>Mesh</tt> class. Figure out where vertices, faces and normals are stored (when available). In this class implement a method that uniformly samples positions and computes the corresponding normal. Additionally implement a method that returns the density function of your importance sampling technique.
						<p> You can perform your sampling by first choosing a triangle from the mesh according to its area, and then sampling uniformly within that triangle. Interpolate the vertex normals when they are provided or compute the normal to the plane defined by the corresponding triangle otherwise. You may find the <tt>DiscretePDF</tt> class useful. For efficiency, build a discrete PDF over triangles once when the activate() method of the <tt>Mesh</tt> is called, and use this precomputed data in your sampling code.
						</p>
					</li>

					<li>
						<h4> <tt>AreaEmitter</tt> Sampling and Density Methods <em>(5 points)</em> </h4>
						With the help of your sampling and density methods implemented in the <tt>Mesh</tt> class, implement the corresponding sampling methods in your area emitter.
						Your density evaluation method takes as input a world space direction (along with the corresponding sampled position and normal on your emitter) generated using your sampling method returns the probability density used when converted to solid angle measure. Make sure to return zero whenever a back facing triangle is encountered.
					</li>
				</ul>
		</li>

		<li>
			<h4>Validation <em> (10 Points)</em></h4>
			<p>
				T-test and validation images.
			</p>
		</li>


	</ul>


	<h3>Part 2: BRDF Sampling <em>(40 points)</em></h3>
	<ul>
		<li>
		<h4>Integrator Implementation <em>(10 Points)</em></h4>

		<p>
			In this part we will implement a new direct illumination integrator (<tt>direct_mats</tt>)
			that can integrate incident radiance from mesh lights and distant disk lights. In addition
			you will implement a new microfacet BRDF. For this part of the assignment you will distribute
			your samples according to a BRDF specific density function :
			\[
				L_o (p,\omega_o) = \approx \frac{1}{N} \sum^N \left( L_e(p,\omega_o) + \frac{L_r(p,\omega_o,\omega_{i,m})}{\text{pdf}_{\text{mat}}(\omega_{i,m})} \right)
			\]
			This integrator should return black for point lights since the probability of intersecting them with this sampling strategy is zero.
		</p>
		</li>

		<li>
			<h4>Microfacet BRDF Evaluation <em> (5 Points)</em></h4>
			<p>
				The Microfacet BRDF you will implement for this part is a simple linear blend between a diffuse BRDF and a rough dielectric microfacet BRDF. Implement <code>Microfacet::eval()</code> which evaluates the described microfacet BRDF for a given pair of directions in local frame:
				\[
					f_r(\bold{\omega_i},\bold{\omega_o}) = \frac{k_d}{\pi} + (1-k_d) \frac{D(\bold{\omega_{h}})~F(\cos{\theta_i},\eta_{e},\eta_{i})~G(\bold{\omega_i},\bold{\omega_o},\bold{\omega_{h}})}{4 \cos{\theta_i} \cos{\theta_o}}, ~~
					\bold{\omega_{h}} = \frac{\left(\bold{\omega_i} + \bold{\omega_o}\right)}{\left|\left|\bold{\omega_i} + \bold{\omega_o}\right|\right|_2}
				\]
				where \(k_d \in [0,1]\) is the RGB diffuse reflection coefficient, \(F\) is the fresnel reflection coefficient (check <tt>common.cpp</tt>), \(\eta_e\) is the exterior index of refraction and \(\eta_i\) is the interior index of refraction. The distribution function \(D\) is the Beckmann distribution:

				\[
					D(\bold{\omega_{h}}) = \frac{e^{\frac{-\tan^2{\theta_{h}}}{\alpha^2}}}{\pi\, \alpha^2 \cos^4 \theta_{h} }

				\]

				with its corresponding shadowing term approximation (Smith):

				\[
					G(\bold{\omega_i},\bold{\omega_o},\bold{\omega_{h}}) = G_1(\bold{\omega_i},\bold{\omega_{h}})~G_1(\bold{\omega_o},\bold{\omega_{h}})
				\]

				\[
					G_1(\bold{\omega_x},\bold{\omega_h}) = \chi^+\left(\frac{\bold{\omega_x}\cdot\bold{\omega_h}}{\bold{\omega_x}\cdot\bold{n}}\right)
					\begin{cases}
						\frac{3.535b+2.181b^2}{1+2.276b+2.577b^2} & b \lt 1.6 \\
						1 										  & \text{otherwise}
					\end{cases} \\

					b = (a \tan{\theta_x})^{-1}, ~~

					\chi^+(c) =
					\begin{cases}
						1 & c > 0 \\
						0 & c \le 0
					\end{cases} \\

				\]

				</p>
		</li>
		<li>
			<h4>Microfacet BRDF Sampling <em> (15 Points)</em></h4>
			<p>
				In this part you will generate samples according to the following density function:
				\[
					k_s ~ D(\omega_h) \cos{\theta_h} ~ J_h + (1-k_s) \frac{\cos{\theta_o}}{\pi}
				\]
				where \(k_s = 1 - \max(k_d)\) and \(J_h = (4 (\omega_h \cdot \omega_o))^{-1}\) is the Jacobian of the half direction mapping.
				This follows the recipe discussed in class, by sampling from the microfacet distribution or from the diffuse component of the BRDF.
			</p>
		</li>
		<li>
			<h4>Validation <em> (10 Points)</em></h4>
			<p>
				Pass the \(\chi^2\) test for the Microfacet BRDF for two different angles and the default roughness parameter \(0.2\). Show your screenshots in your report.
				In addition show a 3-way comparison of the glossy Cornell box scene rendered using <tt>direct_ems</tt>, <tt>direct_mats</tt>,  and the reference.
			</p>
		</li>


	</ul>


	<h3>Part 3: Multiple Importance Sampling <em>(20 Points)</em></h3>
	<ul>
		<li>
			<h4>Integrator Implementation <em>(10 Points)</em></h4>
			<p>
				In this part we will implement another direct illumination integrator (<tt>direct_mis</tt>)
				This integrator will combine both sampling strategies for computing direct illumination by using multiple importance sampling with the balance heuristic.
				At your first camera ray intersection you will sample using both strategies: sampling the emitters and sampling the corresponding BSDF. You will then combine the
				two estimates by using the following:
			</p>

			\[
				  L_o (p,\omega_o) \approx \frac{1}{N} \sum^N \left(
						L_e(p,\omega_o) + w_\text{em}\frac{L_r(p,\omega_o,\omega_{i,e}) }{\text{pdf}_\text{em}(\omega_{i,e})}

					+ w_\text{mat} \frac{L_r(p,\omega_o,\omega_{i,m}) }{\text{pdf}_\text{mat}(\omega_{i,m})}
					\right)\\
					w_\text{em} = \frac{\text{pdf}_\text{em}(\omega_{i,e}) }{\text{pdf}_{\text{em}}(\omega_{i,e})+\text{pdf}_{\text{mat}}(\omega_{i,e})}, ~ ~
					w_\text{mat} = \frac{\text{pdf}_\text{mat}(\omega_{i,m}) }{\text{pdf}_{\text{em}}(\omega_{i,m})+\text{pdf}_{\text{mat}}(\omega_{i,m})}
			\]

		<li>
			<h4>Validation <em> (10 Points)</em></h4>
			<p>
				Pass the \(\chi^2\) test for the Microfacet BRDF for two different angles and the default roughness parameter \(0.2\). Show your screenshots in your report.
				In addition show a 3-way comparison of the glossy Cornell box scene rendered using <tt>direct_ems</tt>, <tt>direct_mats</tt>,  and the reference.
			</p>
		</li>


	</ul>


	<h3>Part 4: Interesting Scene <em>(10 Points)</em></h3>

	Make your own interesting scene and submit a rendering (or several) using any combination of the implemented techniques. The filename format for this scene should be <tt>interesting-pa3-firstname-familyname-N}</tt>, where N depends on how many interesting images you are submitting. Be creative, your renderings will be posted on the Course Gallery.

	<h3> Hacker Points: Specialized Light Source Sampling <em>(20 points)</em></h3>

	<div class="alert alert-info" role="alert"><b>Disclaimer</b>: Hacker points are “underpriced” bonus points
	for the daring few. Sometimes you might be required to implement something that was not taught in class and
	you might have to do some research and creative thinking. Hacker Points are awarded only to students who
	implemented all of the remaining assignment. In addition Hacker Points are either fully awarded or not awarded at all.
	</div>

	<p>
		For this part your task is to create efficient specialized emitters (rectangle,
		sphere and disk lights) that can improve the sample variance of your
		integrators with respect to your current generalized mesh emitter implementation.
		Your main goals are to identify sources of variance in the existing
		implementation, address them and validate your results. Possible sources of variance are:
		<ul>
			<li> Zero contribution (wasted) samples (e.g. not visible samples on a sphere light). </li>
			<li> High variance samples (e.g. distance squared in density function). </li>
			<li> Bad distribution of samples (e.g. clumping of samples because of independent sampling). </li>
		</ul>
	</p>

	<p>

	</p>


	<h4> What to submit </h4>
	<p>
		<ul>
			<li> Implementation of your specialized classes for each emitter which passes your t-tests.</li>
			<li> A paragraph in your report (per emitter) explaining the optimizations you implemented and how they relate to the aforementioned sources of variance.</li>
			<li> Your t-test xml files (for each emitter: a file with 3+ tests each).</li>
			<li> A table and a paragraph in your report summarizing the variance improvement for your test cases.</li>
			<li> An equal sample count comparison with your previous generalized implementation of a scene featuring all emitters.</li>
			<li> Citations for any papers/ideas that are not yours.</li>
		</ul>
	</p>

</div>
