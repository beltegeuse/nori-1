<div style="margin-top:-20px; text-align:justify">

	\(
	   \def\bold#1{\boldsymbol{#1}}
	   \def\vp{p}
	   \def\vr{r}
	   \def\integrand{\mathcal{F}}
	   \definecolor{red}{RGB}{203,23,206}
	\)

	<div class="row" style="margin: 30px">
		<div class="col-md-4">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/cbox_path_mis.png"><img src="images/cbox_path_mis.png"/></a>
				<div class="caption">
					A cornell box with a mirror and a glass ball illuminated by an area light. This scene was rendered
					using path tracing and multiple importance sampling at 1024 samples per pixel.
				</div>
			</div>
		</div>
		<div class="col-md-4">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/table_path_mis.png"><img src="images/table_path_mis.png"/></a>
				<div class="caption">
					A table with a microfacet bowl and a glass illuminated by two area lights. This scene was rendered
					using path tracing and multiple importance sampling at 512 samples per pixel.
				</div>
			</div>
		</div>
		<div class="col-md-4">
			<div class="thumbnail" style="margin: 10px">
				<a class="fancybox" href="images/clocks_pmap.png"><img src="images/clocks_pmap.png"/></a>
				<div class="caption">
					The clocks scene from <a href ="http://www.ci.i.u-tokyo.ac.jp/~hachisuka/sppm.pdf"> Hackisuka et al.</a>
					rendered using photon mapping and 40M photons.
				</div>
			</div>
		</div>

	</div>

	<h3>Preliminaries</h3>


	<p>
		Begin by importing the base code updates into your repository by
		running <tt>git pull</tt>, cmake and recompiling. If there were any concurrent
		changes to the same file, you may have to perform a <em>merge</em> (see
		the git tutorials under "Preliminaries" for more information).
	</p>

	<p>
		In this exercise you be implementing several global illumination integrators and
		a BSDF to model smooth dielectric surfaces. Your new integrators will
		approximate the solution of the rendering equation as discussed in
		class:
	</p>
	\[
		L_o (\vp,\omega_o) = L_e(\vp,\omega_o) + \int_{H^2} f_r (\vp,\omega_o,\omega_i)\,L_i (\vp,\omega_i) \, \mathrm{d} \omega_i.
	\]
	where \(f_r\) is the BRDF, \(p\) is a surface position and \(L_i\) and
	\(L_o\) denote the incident and outgoing radiance functions. In comparison
	to the prior assignment, we do not truncate the recursion and are thus
	interested in estimators for the full solution of this equation.

	<h3>Part 1: Dielectric BSDF <em>(10 points)</em></h3>
	<p>
		In this part, you will add one more surface reflection model which
		has been sorely missing thus far: a BSDF which models a smooth dielectric
		interface.

		Dielectric interfaces (such as a transition from air to glass or water,
		etc.) both reflect and refract incident illumination. The rules for
		determining the direction and amount of scattered energy are given by the law
		of specular reflection, Snells law, and the Fresnel equations. All of them
		can be found in the course slides.

		Following the usual Monte Carlo approach, the sampling code will make a
		random choice to determine how light is scattered. In particular, the
		probability that a reflection or refraction event takes place is
		proportional to the reflection coefficient provided by the Fresnel equations.
		Since there is no absorption, the corresponding <code>BSDF::sample()</code>
		routine should always return an importance sampling weight of <code>1.0</code>.
		The updated base code
		already comes with a skeleton implementation in <tt>src/dielectric.cpp</tt>
		which can be instantiated via the following XML syntax:
	</p>


<pre class="prettyprint linenums lang-xml">
&lt;bsdf type="dielectric"&gt;
    &lt;!-- Interior index of refraction --&gt;
    &lt;float name="intIOR" value="1.5"/&gt;
    &lt;!-- Exterior index of refraction --&gt;
    &lt;float name="extIOR" value="1"/&gt;
&lt;/bsdf&gt;</pre>

	<p>
		It may be helpful to see a complete implementation of a specular/delta
		function reflection model which scatters an incident ray into a
		discrete set of directions. For this, take a look at the mirror BRDF in
		<tt>src/mirror.cpp</tt> (also provided with the new base code).
	</p>

	<h3>Part 2: Path Tracing <em>(40 points)</em></h3>
	<ul>
		<li>
			<h4><tt>path_mats</tt> implementation <em>(10 Points)</em></h4>

			<p>
				In this part you will implement a naive global illumination
				path tracing integrator (<tt>path_mats</tt>) which is an
				estimator of the rendering equation using only BSDF sampling;
				paths only contribute when they randomly hit a light source.
				Your <tt>direct_mats</tt> integrator should be a great start:
				you just have to add the recursion.
				Use the Russian roulette technique as a path termination
				criterion to avoid infinite recursion.
			</p>
		</li>

		<li>
			<h4><tt>path_mis</tt> implementation <em>(20 Points)</em></h4>

			<p>
				In this part you will implement a more advanced path tracer (<tt>path_mis</tt>)
				which solves the rendering equation by performing both BSDF sampling and emitter sampling and
				combining the two strategies using multiple importance sampling as discussed in class.
				Use the Russian roulette technique as a path termination
				criterion to avoid infinite recursion.
			</p>
		</li>

		<li>
			<h4>Validation <em> (10 Points)</em></h4>
			<p>
				Pass the related tests found in <tt>./scenes/pa4/tests</tt>:
				<ul>
					<li> <tt>test-direct.xml</tt>, </li>
					<li> <tt>test-furnace.xml</tt> </li>
				</ul>
			</p>
			<p>
				Using <tt>path_mats</tt> and <tt>path_mis</tt> render the following scenes found in <tt>./scenes/pa4</tt> :
				<ul>
					<li><tt>cbox/cbox_mats.xml</tt>, </li>
					<li><tt>cbox/cbox_mis.xml</tt>, </li>
					<li><tt>table/table_mats.xml</tt>, </li>
					<li><tt>table/table_mis.xml</tt>, </li>
				</ul>
				In your report provide two 3-way comparisons of your rendering results and the mis reference.
			</p>
		</li>
	</ul>

	<h3>Part 3: Photon Mapping <em>(40 points)</em></h3>
	<p>
		In this part you will be implementing a basic version of a photon map
		integrator which provides a direct visualization (i.e. without
		final gathering) of the photon map on diffuse surfaces and behaves like
		a path tracer elsewhere. This two pass technique provides a biased
		estimate of the rendering equation and has better qualitative
		performance for certain classes of light transport.
	</p>
	<p>
		The new base code comes with various helper components to facilitate this
		exercise as much as possible:
		<ul>
			<li>We provide photon map data structure for your convenience. It
				is split up into three files: <tt>include/nori/kdtree.h</tt>
				for the generic kd-tree and a specialization to photons in
				<tt>include/nori/photon.h</tt> and <tt>src/photon.cpp</tt>.
			</li>
			<li>
				We added a two new functions to the core renderer API: there is a new
				function <code>Integrator::preprocess</code> that can be overridden by
				the photon mapper to implement the photon tracing pass, and a function
				<code>BSDF::isDiffuse</code> to distinguish diffuse and non-diffuse
				surfaces.
			</li>
			<li>
				The base code comes with a skeleton implementation of the photon mapper
				in <tt>src/photonmapper.cpp</tt> which shows how to populate, build, and query
				the photon map.
			</li>
		</ul>

		During the first pass in <code>PhotonMapper::preprocess</code>, an unknown number of photons will be emitted from all
		light sources and then consecutively traced and stored in a <tt>PhotonMap</tt> data structure. The process stops
		when the photons stored in the <tt>PhotonMap</tt> reach the pre-defined number of photons (<tt>photonCount</tt>).
		During the second pass in <code>PhotonMapper::Li</code>, paths are traced from the camera much like in a regular
		path tracer, except that photon queries are executed whenever an intersection with a diffuse surface is found.
		The way of instantiating a <tt>photonmapper</tt> in the XML description language looks as follows:
	</p>

<pre class="prettyprint linenums lang-xml">
&lt;integrator type="photonmapper"&gt;
    &lt;!-- Total number of emitted photons (1M) --&gt;
    &lt;integer name="photonCount" value="1000000"/&gt;
    &lt;!-- Photon Query Radius --&gt;
    &lt;float name="photonRadius" value="1.5"/&gt;
&lt;/integrator&gt;</pre>

The following list provides further detail on key steps that have to be implemented:

	<ul>
		<li>
			<h4> Photon Emission from Mesh Area Lights (5 Points)</em></h4>
				 <p>
					Add support for photon emission for only mesh area
					lights. You will have to find an appropriate interface
					(e.g. a new function <code>Emitter::samplePhoton()</code>) to
					do this. It is also a good idea to add a generic photon
					sampling routine (e.g. to the Scene), which randomly chooses an
					emitter and in turn calls its photon sampling implementation.
				</p>
				<p>
					Implementation: first, uniformly choose a location on the surface
					and then choose a cosine-weighted random direction over the hemisphere around the surface normal.
					The power of the photon is \(\pi\cdot A\cdot L_e/N\), where \(L_e\) is the emitted radiance, \(N\)
					is the number of photons and \(A\) is the total surface area of the mesh light.
				</p>
		</li>

		<li>
			<h4>Photon Tracing and Storage (10 Points)</em></h4>
			<p>
				After a photon is sampled, the photon mapper traces it through
				the scene much like paths are propagated in the
				<tt>path_mats</tt> integrator, i.e. by repeatedly sampling a
				direction from a BSDF, tracing a path in the sampled direction
				and using a russian roulette termination criterion to prevent
				infinite recursion. The sampling weights from the BSDF and
				russian roulette steps are continually multiplied into the
				photon weight. Each time a diffuse surface is intersected, a
				photon record is created in the photon map. Once enough photons
				have been collected, the iteration stops and invokes the
				<code>PhotonMap::build()</code> routine.
			</p>

		</li>

		<li>
			<h4>Rendering/Radiance Estimation <em> (15 Points)</em></h4>
			<p>
				In the second pass, paths are traced through the scene starting
				from the camera (by <code>PhotonMapper::Li</code>) to estimate
				the incident illumination. Once again, this piece of code is
				almost identical to what you implemented in <tt>path_mats</tt>.
				The only difference is that, whenever a diffuse surface is
				intersected, the algorithm queries the photon map and
				immediately terminates the recursion.
				For non-diffuse surface, the integrator samples a direction from
				a BSDF, traces a ray in this direction, and so on (once more,
				using the Russian roulette technique to avoid infinite recursion).
				Detail on the photon map density estimation step is provided in
				the course slides.
			</p>
		</li>

		<li>
			<h4>Validation <em> (10 Points)</em></h4>
			<p>
				Using <tt>photonmapper</tt> render the following scenes found in <tt>./scenes/pa4</tt> :
				<ul>
					<li><tt>cbox/cbox_pmap.xml</tt>, </li>
					<li><tt>clocks/clocks_pmap.xml</tt>, </li>
					<li><tt>table/table_pmap.xml</tt>, </li>
				</ul>
				In your report provide a 2-way comparison of your rendering results and the photon mapping reference.
				Explain in your report any differences.
			</p>
		</li>


	</ul>

	<h3>Part 4: Interesting Scene <em>(10 Points)</em></h3>

	Make your own interesting scene and submit a rendering (or several) using any combination of the implemented techniques. The filename format for this scene should be <tt>interesting-pa4-firstname-familyname-N}</tt>, where N depends on how many interesting images you are submitting. The aspect ratio of your image should be 4:3. Be creative, your renderings will be posted on the Course Gallery.

	<h3> Hacker Points: Progressive updates <em>(20 points)</em></h3>

	<p>
		For this part your task is to extend your renderer such that it can
		display intermediate results of an "infinitely long" rendering session
		where the result continually improves. For path tracing integrators
		show the noisy estimate of the image after every pass with a few number
		of samples. For the photon mapper, show a progressive estimate of the
		image starting with a large search radius and then progressively
		reducing it. Use the algorithm described in Figure 13 of Knaus and
		Zwicker
		<a href="http://cgg.unibe.ch/publications/2011/progressive-photon-mapping-a-probabilistic-approach">[2011]</a>
	</p>

</div>
